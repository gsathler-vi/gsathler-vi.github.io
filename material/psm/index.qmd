---
title: "Avaliação de Impacto Causal com Propensity Score Matching"
subtitle: "Estimação do Efeito das Políticas de Inclusão e Permanência sobre o Desempenho Acadêmico"
execute:
  eval: true
bibliography: references.bib
---

Para testar a Hipótese 1, que postula um efeito **causal** das políticas de permanência sobre o desempenho acadêmico, a análise por regressão convencional é insuficiente devido ao problema fundamental de **auto-seleção** [@facure_causal_inference; @huntington_klein_effect].

::: callout-note
## Objetivo

Estimar o efeito causal das políticas de inclusão (ProUni, FIES) e permanência (auxílios) sobre o desempenho acadêmico no ENADE, utilizando Propensity Score Matching (PSM) para mitigar o viés de seleção.
:::

## Estrutura das Análises

As análises estão organizadas em três blocos principais, respeitando a natureza institucional de cada política:

### Bloco 1: Políticas de Inclusão (IES Privadas vs Pagantes)

Cada política é comparada com estudantes **pagantes** (sem bolsa/financiamento) nas mesmas IES privadas.

| Tratamento            | Controle                  |
|-----------------------|---------------------------|
| ProUni Integral       | Pagantes (sem bolsa/FIES) |
| ProUni Parcial        | Pagantes (sem bolsa/FIES) |
| FIES                  | Pagantes (sem bolsa/FIES) |
| ProUni Parcial + FIES | Pagantes (sem bolsa/FIES) |

### Bloco 2: Políticas de Permanência (IES Públicas)

| Tratamento          | Amostra      |
|---------------------|--------------|
| Auxílio Permanência | IES Públicas |
| Auxílio Alimentação | IES Públicas |

### Bloco 3: Auxílios entre Estudantes com Curso Gratuito

Analisa o efeito **incremental** dos auxílios de permanência sobre estudantes que já possuem **gratuidade total** (IES públicas + ProUni Integral).

| Tratamento          | Amostra                              |
|---------------------|--------------------------------------|
| Auxílio Permanência | Curso Gratuito (Públicas + ProUni)   |
| Auxílio Alimentação | Curso Gratuito (Públicas + ProUni)   |

------------------------------------------------------------------------

## Configuração e Carga dos Dados

```{python}
#| code-fold: true
#| code-summary: "Expandir configuração"
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.linear_model import LogisticRegression
from sklearn.neighbors import NearestNeighbors
from scipy.stats import ttest_ind
import statsmodels.api as sm
from IPython.display import display, Markdown
import warnings
warnings.filterwarnings('ignore')

# Configurações
sns.set_style("whitegrid")
plt.rcParams['figure.figsize'] = (10, 6)

# Paleta de cores do projeto
PALETTE_MAIN = ['#75A8D9', '#72994E', '#EE6331', '#E7B10A', '#419599', '#447099', '#D44000', '#404041']

# Nível de significância padrão
ALPHA = 0.05

# Mapeamentos
MAP_CURSO = {1: 'Administração', 13: 'Ciências Econômicas', 22: 'Ciências Contábeis'}
```

### Carregamento da Base de Dados

```{python}
df_full = pd.read_parquet('dataset/01_enade.parquet')
display(Markdown(f"✅ **Dados carregados:** {len(df_full):,} observações"))

# Criar subconjuntos
df_privadas = df_full[df_full['cod_ies_cat'] != 1].copy()
df_publicas = df_full[df_full['cod_ies_cat'] == 1].copy()

# Grupo de controle: pagantes sem nenhuma bolsa ou financiamento
df_pagantes = df_privadas[
    (df_privadas['prouni_int'] == 0) & 
    (df_privadas['prouni_par'] == 0) & 
    (df_privadas['fies'] == 0) &
    (df_privadas['prouni_fies'] == 0)
].copy()

display(Markdown(f"""
### Distribuição da Amostra

| Categoria | N | % |
|-----------|---:|---:|
| IES Públicas | {len(df_publicas):,} | {len(df_publicas)/len(df_full)*100:.1f}% |
| IES Privadas | {len(df_privadas):,} | {len(df_privadas)/len(df_full)*100:.1f}% |
| Pagantes (Controle) | {len(df_pagantes):,} | {len(df_pagantes)/len(df_privadas)*100:.1f}% das privadas |
"""))
```

------------------------------------------------------------------------

## Definição das Covariáveis

::: callout-tip
## Seleção de Covariáveis

A literatura recomenda incluir todas as variáveis associadas **tanto à decisão de tratamento quanto ao resultado**, mesmo que não sejam estatisticamente significantes no modelo Logit [@facure_causal_inference].
:::

```{python}
# Variável de Resultado
resultado = 'nt_ger'

# Covariáveis para o Propensity Score
covariates_base = [
    'cod_pessoas_res',
    'genero_fem',
    'cor_preta', 'cor_parda',
    'renda_fx2', 'renda_fx3', 'renda_fx4', 'renda_fx5',
    'em_maioria_pub', 'em_metade_pub', 'em_maioria_priv', 'em_total_priv',
    'esc_resp_f1', 'esc_resp_f2', 'esc_resp_em', 'esc_resp_sup'
]

display(Markdown(f"**Total de covariáveis:** {len(covariates_base)}"))
```

------------------------------------------------------------------------

## Funções Auxiliares para PSM

```{python}
#| code-fold: true
#| code-summary: "Expandir funções auxiliares"

def calculate_smd(df, treatment_col, var_col):
    """Calcula a Diferença de Médias Padronizada (SMD)."""
    tratados = df[df[treatment_col] == 1][var_col]
    controles = df[df[treatment_col] == 0][var_col]
    
    if len(tratados) == 0 or len(controles) == 0:
        return 0
    
    mean_diff = tratados.mean() - controles.mean()
    pooled_std = np.sqrt((tratados.var(ddof=1) + controles.var(ddof=1)) / 2)
    
    if pooled_std == 0:
        return 0
    return mean_diff / pooled_std


def run_psm_analysis(df, tratamento, resultado, covariates, nome_tratamento, min_tratados=30, show_logit=True):
    """Executa análise completa de PSM para um tratamento específico."""
    colunas = [resultado, tratamento] + covariates
    df_psm = df[colunas].dropna().copy()
    
    n_total = len(df_psm)
    n_tratados = int(df_psm[tratamento].sum())
    n_controles = n_total - n_tratados
    
    if n_tratados < min_tratados:
        return {'erro': f'Amostra insuficiente: apenas {n_tratados} tratados (mínimo: {min_tratados})'}
    
    if n_controles < min_tratados:
        return {'erro': f'Amostra insuficiente: apenas {n_controles} controles (mínimo: {min_tratados})'}
    
    X = df_psm[covariates]
    y = df_psm[tratamento]
    
    # Modelo Logit com statsmodels para sumário (com tratamento de erro)
    logit_sm = None
    try:
        X_sm = sm.add_constant(X)
        logit_sm = sm.Logit(y, X_sm).fit(disp=0, method='bfgs', maxiter=100)
    except Exception as e:
        # Se falhar, tenta método alternativo ou ignora o sumário
        try:
            logit_sm = sm.Logit(y, X_sm).fit(disp=0, method='lbfgs', maxiter=100)
        except:
            logit_sm = None  # Sumário não disponível
    
    # Sklearn para predição (mais robusto)
    logit_model = LogisticRegression(max_iter=1000, solver='liblinear', C=1.0)
    logit_model.fit(X, y)
    
    df_psm['propensity_score'] = logit_model.predict_proba(X)[:, 1]
    
    tratados = df_psm[df_psm[tratamento] == 1]
    controles = df_psm[df_psm[tratamento] == 0]
    
    nn = NearestNeighbors(n_neighbors=1, algorithm='ball_tree')
    nn.fit(controles['propensity_score'].values.reshape(-1, 1))
    distances, indices = nn.kneighbors(tratados['propensity_score'].values.reshape(-1, 1))
    
    matched_controles = controles.iloc[indices.flatten()]
    df_matched = pd.concat([tratados, matched_controles])
    
    media_tratados = df_matched[df_matched[tratamento] == 1][resultado].mean()
    media_controles = df_matched[df_matched[tratamento] == 0][resultado].mean()
    att = media_tratados - media_controles
    
    ttest = ttest_ind(
        df_matched[df_matched[tratamento] == 1][resultado],
        df_matched[df_matched[tratamento] == 0][resultado]
    )
    
    balance = []
    for var in covariates:
        smd_antes = calculate_smd(df_psm, tratamento, var)
        smd_depois = calculate_smd(df_matched, tratamento, var)
        balance.append({
            'Variável': var,
            'SMD Antes': round(smd_antes, 4),
            'SMD Depois': round(smd_depois, 4),
            'Equilibrado': '✅' if abs(smd_depois) < 0.1 else '⚠️'
        })
    
    df_balance = pd.DataFrame(balance)
    n_equilibradas = sum(1 for b in balance if b['Equilibrado'] == '✅')
    
    return {
        'nome': nome_tratamento,
        'n_total': n_total,
        'n_tratados': n_tratados,
        'n_controles': n_controles,
        'media_tratados': media_tratados,
        'media_controles': media_controles,
        'att': att,
        'p_valor': ttest.pvalue,
        'significante': ttest.pvalue < ALPHA,
        'df_balance': df_balance,
        'n_equilibradas': n_equilibradas,
        'pct_equilibradas': n_equilibradas / len(covariates) * 100,
        'df_psm': df_psm,
        'df_matched': df_matched,
        'logit_summary': logit_sm
    }


def display_psm_results(resultado_psm, show_logit=True):
    """Exibe resultados do PSM de forma padronizada."""
    if 'erro' in resultado_psm:
        display(Markdown(f"⚠️ **{resultado_psm['erro']}**"))
        return
    
    sig_emoji = '✅' if resultado_psm['significante'] else '❌'
    
    display(Markdown(f"""
### Resultados: {resultado_psm['nome']}

| Métrica | Valor |
|---------|-------|
| N Total | {resultado_psm['n_total']:,} |
| N Tratados | {resultado_psm['n_tratados']:,} |
| N Controles | {resultado_psm['n_controles']:,} |
| Nota Média (Tratados) | {resultado_psm['media_tratados']:.4f} |
| Nota Média (Controles Pareados) | {resultado_psm['media_controles']:.4f} |
| **ATT (Efeito Causal)** | **{resultado_psm['att']:.4f}** |
| P-valor | {resultado_psm['p_valor']:.4f} |
| Significante (α={ALPHA}) | {sig_emoji} |
| Covariáveis Equilibradas | {resultado_psm['n_equilibradas']}/{len(resultado_psm['df_balance'])} ({resultado_psm['pct_equilibradas']:.0f}%) |
"""))
    
    if show_logit and 'logit_summary' in resultado_psm and resultado_psm['logit_summary'] is not None:
        display(Markdown("#### Modelo Logit para Propensity Score"))
        display(resultado_psm['logit_summary'].summary())


def plot_love_plot(df_balance, titulo):
    """Gera Love Plot para verificação de equilíbrio."""
    fig, ax = plt.subplots(figsize=(10, 8))
    y_pos = range(len(df_balance))
    
    ax.scatter(df_balance['SMD Antes'], y_pos, color=PALETTE_MAIN[0], 
               marker='o', s=80, label='Antes do Matching', zorder=3)
    ax.scatter(df_balance['SMD Depois'], y_pos, color=PALETTE_MAIN[2], 
               marker='s', s=80, label='Após o Matching', zorder=3)
    
    ax.axvline(0, color='gray', linestyle='--', alpha=0.7)
    ax.axvline(0.1, color=PALETTE_MAIN[1], linestyle=':', linewidth=2, label='Limiar (±0.1)')
    ax.axvline(-0.1, color=PALETTE_MAIN[1], linestyle=':', linewidth=2)
    
    ax.set_yticks(y_pos)
    ax.set_yticklabels(df_balance['Variável'])
    ax.set_xlabel('Diferença de Médias Padronizada (SMD)')
    ax.set_title(f'Verificação de Equilíbrio - {titulo}', fontweight='bold')
    ax.legend(loc='lower right')
    ax.grid(axis='x', alpha=0.3)
    plt.tight_layout()
    plt.show()


def plot_ps_distribution(df_psm, tratamento, titulo):
    """Gera gráfico de distribuição dos propensity scores."""
    fig, ax = plt.subplots(figsize=(10, 5))
    
    tratados = df_psm[df_psm[tratamento] == 1]['propensity_score']
    controles = df_psm[df_psm[tratamento] == 0]['propensity_score']
    
    ax.hist(controles, bins=50, alpha=0.6, label='Controle', color=PALETTE_MAIN[0], density=True)
    ax.hist(tratados, bins=50, alpha=0.6, label='Tratamento', color=PALETTE_MAIN[2], density=True)
    
    ax.set_xlabel('Propensity Score')
    ax.set_ylabel('Densidade')
    ax.set_title(f'Distribuição dos Propensity Scores - {titulo}', fontweight='bold')
    ax.legend()
    plt.tight_layout()
    plt.show()
```

------------------------------------------------------------------------

## Bloco 1: Políticas de Inclusão (IES Privadas vs Pagantes)

::: callout-important
## Estratégia de Identificação

Cada política de inclusão é comparada com estudantes **pagantes** nas mesmas IES privadas — aqueles que não possuem ProUni, FIES ou outras bolsas. Esta comparação permite isolar o efeito da política controlando por características observáveis.
:::

### ProUni Integral vs Pagantes

```{python}
# Tratados: ProUni Integral
df_prouni_int = df_privadas[df_privadas['prouni_int'] == 1].copy()
df_prouni_int['tratamento'] = 1

# Controles: Pagantes
df_controle = df_pagantes.copy()
df_controle['tratamento'] = 0

df_analise1 = pd.concat([df_prouni_int, df_controle])

resultado_prouni_int = run_psm_analysis(
    df_analise1, 'tratamento', resultado, covariates_base, 
    'ProUni Integral vs Pagantes'
)
display_psm_results(resultado_prouni_int)

if 'erro' not in resultado_prouni_int:
    plot_ps_distribution(resultado_prouni_int['df_psm'], 'tratamento', 'ProUni Integral vs Pagantes')
    plot_love_plot(resultado_prouni_int['df_balance'], 'ProUni Integral vs Pagantes')
```

### ProUni Parcial vs Pagantes

```{python}
df_prouni_par = df_privadas[df_privadas['prouni_par'] == 1].copy()
df_prouni_par['tratamento'] = 1

df_controle = df_pagantes.copy()
df_controle['tratamento'] = 0

df_analise2 = pd.concat([df_prouni_par, df_controle])

resultado_prouni_par = run_psm_analysis(
    df_analise2, 'tratamento', resultado, covariates_base,
    'ProUni Parcial vs Pagantes'
)
display_psm_results(resultado_prouni_par)

if 'erro' not in resultado_prouni_par:
    plot_ps_distribution(resultado_prouni_par['df_psm'], 'tratamento', 'ProUni Parcial vs Pagantes')
    plot_love_plot(resultado_prouni_par['df_balance'], 'ProUni Parcial vs Pagantes')
```

### FIES vs Pagantes

```{python}
df_fies = df_privadas[df_privadas['fies'] == 1].copy()
df_fies['tratamento'] = 1

df_controle = df_pagantes.copy()
df_controle['tratamento'] = 0

df_analise3 = pd.concat([df_fies, df_controle])

resultado_fies = run_psm_analysis(
    df_analise3, 'tratamento', resultado, covariates_base,
    'FIES vs Pagantes'
)
display_psm_results(resultado_fies)

if 'erro' not in resultado_fies:
    plot_ps_distribution(resultado_fies['df_psm'], 'tratamento', 'FIES vs Pagantes')
    plot_love_plot(resultado_fies['df_balance'], 'FIES vs Pagantes')
```

### ProUni Parcial + FIES vs Pagantes

```{python}
df_prouni_fies = df_privadas[df_privadas['prouni_fies'] == 1].copy()
df_prouni_fies['tratamento'] = 1

df_controle = df_pagantes.copy()
df_controle['tratamento'] = 0

df_analise4 = pd.concat([df_prouni_fies, df_controle])

resultado_prouni_fies = run_psm_analysis(
    df_analise4, 'tratamento', resultado, covariates_base,
    'ProUni Parcial + FIES vs Pagantes'
)
display_psm_results(resultado_prouni_fies)

if 'erro' not in resultado_prouni_fies:
    plot_ps_distribution(resultado_prouni_fies['df_psm'], 'tratamento', 'ProUni+FIES vs Pagantes')
    plot_love_plot(resultado_prouni_fies['df_balance'], 'ProUni+FIES vs Pagantes')
```

------------------------------------------------------------------------

## Bloco 2: Políticas de Permanência (IES Públicas)

::: callout-note
## Escopo Amostral

Os auxílios de permanência (PNAES) são concentrados nas IES públicas. Portanto, analisamos o efeito desses auxílios comparando beneficiários com não-beneficiários dentro das instituições públicas.
:::

### Auxílio Permanência (IES Públicas)

```{python}
resultado_aux_perm = run_psm_analysis(
    df_publicas, 'aux_perm', resultado, covariates_base, 
    'Auxílio Permanência (IES Públicas)'
)
display_psm_results(resultado_aux_perm)

if 'erro' not in resultado_aux_perm:
    plot_ps_distribution(resultado_aux_perm['df_psm'], 'aux_perm', 'Auxílio Permanência')
    plot_love_plot(resultado_aux_perm['df_balance'], 'Auxílio Permanência')
```

### Auxílio Alimentação (IES Públicas)

```{python}
resultado_aux_alim = run_psm_analysis(
    df_publicas, 'aux_alim', resultado, covariates_base,
    'Auxílio Alimentação (IES Públicas)'
)
display_psm_results(resultado_aux_alim)

if 'erro' not in resultado_aux_alim:
    plot_ps_distribution(resultado_aux_alim['df_psm'], 'aux_alim', 'Auxílio Alimentação')
    plot_love_plot(resultado_aux_alim['df_balance'], 'Auxílio Alimentação')
```

---

## Bloco 3: Efeito da Gratuidade com Auxílios de Permanência

::: {.callout-important}
## Justificativa Metodológica

Neste bloco, investigamos o **efeito incremental** das políticas de permanência (auxílios do PNAES) sobre o desempenho acadêmico de estudantes que já possuem **gratuidade total** no curso.

### Por que usar `curso_gratuito` em vez de `prouni_int`?

A variável **`curso_gratuito`** abrange tanto cursos em **IES públicas** quanto beneficiários de **ProUni Integral** em IES privadas, representando o universo de estudantes com gratuidade plena. Esta escolha metodológica apresenta vantagens:

1. **Maior comparabilidade institucional**: Estudantes de IES públicas e privadas com ProUni Integral compartilham a característica fundamental de **isenção total de mensalidade**, mas diferem no acesso a auxílios de permanência.

2. **Controle pelo viés de seleção institucional**: Ao incluir ambos os grupos no universo de "gratuidade", evitamos confundir o efeito da permanência com preferências por tipo de instituição.

3. **Foco na política de permanência**: A comparação isola o efeito dos **auxílios** (tratamento) mantendo constante a **gratuidade** (característica compartilhada).

### Estratégia de Identificação

Comparamos estudantes com **curso gratuito** que:

- **Grupo Tratamento**: Recebem auxílio de permanência/alimentação (principalmente IES públicas)
- **Grupo Controle**: Não recebem auxílio (IES públicas sem auxílio + ProUni Integral sem auxílio)

Esta estratégia responde: *"Dentre quem já tem gratuidade, receber auxílio de permanência melhora o desempenho?"*
:::

::: {.callout-warning}
## Covariáveis Específicas para Comparação Inter-Institucional

Para comparar estudantes entre instituições públicas e privadas, utilizamos um conjunto reduzido de covariáveis que:

1. **Não incluem** características institucionais (evita colinearidade perfeita com o tratamento)
2. **Focam** em características socioeconômicas e demográficas comparáveis entre setores
3. **Evitam** variáveis que podem ter significados diferentes entre setores (ex: bolsas internas)
:::

```{python}
# Covariáveis específicas para comparação entre instituições
# Excluímos variáveis institucionais e focamos em características do estudante
covariates_bloco3 = [
    'cod_pessoas_res',
    'genero_fem',
    'cor_preta', 'cor_parda',
    'renda_fx2', 'renda_fx3', 'renda_fx4', 'renda_fx5',
    'em_total_pub',  # Ensino médio público (mais simples)
    'esc_resp_em', 'esc_resp_sup'  # Escolaridade dos pais (reduzido)
]

display(Markdown(f"**Covariáveis para Bloco 3:** {len(covariates_bloco3)} variáveis"))
display(Markdown(f"Variáveis: {', '.join(covariates_bloco3)}"))
```

### Auxílio Permanência entre Estudantes com Curso Gratuito

```{python}
# Filtrar apenas estudantes com curso gratuito
df_gratuito = df_full[df_full['curso_gratuito'] == 1].copy()

display(Markdown(f"""
### Composição da Amostra (Curso Gratuito)

| Categoria | N | % |
|-----------|---:|---:|
| IES Pública | {len(df_gratuito[df_gratuito['cod_ies_cat'] == 1]):,} | {len(df_gratuito[df_gratuito['cod_ies_cat'] == 1])/len(df_gratuito)*100:.1f}% |
| ProUni Integral (Privada) | {len(df_gratuito[df_gratuito['prouni_int'] == 1]):,} | {len(df_gratuito[df_gratuito['prouni_int'] == 1])/len(df_gratuito)*100:.1f}% |
| **Total com Gratuidade** | **{len(df_gratuito):,}** | **100%** |
| Com Auxílio Permanência | {len(df_gratuito[df_gratuito['aux_perm'] == 1]):,} | {len(df_gratuito[df_gratuito['aux_perm'] == 1])/len(df_gratuito)*100:.1f}% |
| Sem Auxílio Permanência | {len(df_gratuito[df_gratuito['aux_perm'] == 0]):,} | {len(df_gratuito[df_gratuito['aux_perm'] == 0])/len(df_gratuito)*100:.1f}% |
"""))

# PSM: Auxílio Permanência entre estudantes com curso gratuito
resultado_aux_perm_gratuito = run_psm_analysis(
    df_gratuito, 'aux_perm', resultado, covariates_bloco3,
    'Auxílio Permanência (entre estudantes com curso gratuito)'
)
display_psm_results(resultado_aux_perm_gratuito)

if 'erro' not in resultado_aux_perm_gratuito:
    plot_ps_distribution(resultado_aux_perm_gratuito['df_psm'], 'aux_perm', 'Auxílio Permanência (Curso Gratuito)')
    plot_love_plot(resultado_aux_perm_gratuito['df_balance'], 'Auxílio Permanência (Curso Gratuito)')
```

### Auxílio Alimentação entre Estudantes com Curso Gratuito

```{python}
display(Markdown(f"""
### Distribuição: Auxílio Alimentação

| Grupo | N | % |
|-------|---:|---:|
| Com Auxílio Alimentação | {len(df_gratuito[df_gratuito['aux_alim'] == 1]):,} | {len(df_gratuito[df_gratuito['aux_alim'] == 1])/len(df_gratuito)*100:.1f}% |
| Sem Auxílio Alimentação | {len(df_gratuito[df_gratuito['aux_alim'] == 0]):,} | {len(df_gratuito[df_gratuito['aux_alim'] == 0])/len(df_gratuito)*100:.1f}% |
"""))

# PSM: Auxílio Alimentação entre estudantes com curso gratuito
resultado_aux_alim_gratuito = run_psm_analysis(
    df_gratuito, 'aux_alim', resultado, covariates_bloco3,
    'Auxílio Alimentação (entre estudantes com curso gratuito)'
)
display_psm_results(resultado_aux_alim_gratuito)

if 'erro' not in resultado_aux_alim_gratuito:
    plot_ps_distribution(resultado_aux_alim_gratuito['df_psm'], 'aux_alim', 'Auxílio Alimentação (Curso Gratuito)')
    plot_love_plot(resultado_aux_alim_gratuito['df_balance'], 'Auxílio Alimentação (Curso Gratuito)')
```

### Comparação por Curso: Auxílios entre Estudantes com Curso Gratuito

```{python}
def run_psm_by_course_gratuito(tratamento, nome_politica, covariates):
    """Executa PSM por curso entre estudantes com curso gratuito."""
    resultados = {}
    
    for cod_curso, nome_curso in MAP_CURSO.items():
        df_curso = df_gratuito[df_gratuito['cod_grupo'] == cod_curso].copy()
        
        resultado_psm = run_psm_analysis(
            df_curso, tratamento, resultado, covariates, 
            f'{nome_politica} - {nome_curso}',
            min_tratados=15,
            show_logit=False
        )
        resultados[nome_curso] = resultado_psm
    
    return resultados


def display_course_comparison_bloco3(resultados_por_curso, nome_politica):
    """Exibe tabela comparativa entre cursos."""
    rows = []
    for curso, res in resultados_por_curso.items():
        if 'erro' not in res:
            rows.append({
                'Curso': curso,
                'N Tratados': res['n_tratados'],
                'ATT': round(res['att'], 4),
                'P-valor': round(res['p_valor'], 4),
                'Sig.': '✅' if res['significante'] else '❌',
                'Equil.': f"{res['pct_equilibradas']:.0f}%"
            })
        else:
            rows.append({
                'Curso': curso,
                'N Tratados': '-',
                'ATT': '-',
                'P-valor': '-',
                'Sig.': '⚠️',
                'Equil.': '-'
            })
    
    df_comp = pd.DataFrame(rows)
    display(Markdown(f"### Comparação por Curso: {nome_politica}"))
    display(df_comp)
    return df_comp


# Auxílio Permanência por curso (entre estudantes com curso gratuito)
resultados_aux_perm_curso_gratuito = run_psm_by_course_gratuito(
    'aux_perm', 'Auxílio Permanência (Curso Gratuito)', covariates_bloco3
)
display_course_comparison_bloco3(resultados_aux_perm_curso_gratuito, 'Auxílio Permanência (Curso Gratuito)')
```

```{python}
# Auxílio Alimentação por curso (entre estudantes com curso gratuito)
resultados_aux_alim_curso_gratuito = run_psm_by_course_gratuito(
    'aux_alim', 'Auxílio Alimentação (Curso Gratuito)', covariates_bloco3
)
display_course_comparison_bloco3(resultados_aux_alim_curso_gratuito, 'Auxílio Alimentação (Curso Gratuito)')
```

------------------------------------------------------------------------

## Análise Estratificada por Curso (Blocos 1 e 2)

::: callout-note
## Objetivo

Verificar se os efeitos das políticas de inclusão (Bloco 1) e permanência (Bloco 2) variam entre os cursos de Administração, Ciências Econômicas e Ciências Contábeis.
:::

```{python}
#| code-fold: true
#| code-summary: "Expandir funções de análise por curso"

def run_psm_vs_pagantes_by_course(df_tratados, df_pagantes, nome_politica):
    """Executa PSM comparando tratados com pagantes por curso."""
    resultados = {}
    
    for cod_curso, nome_curso in MAP_CURSO.items():
        df_trat_curso = df_tratados[df_tratados['cod_grupo'] == cod_curso].copy()
        df_trat_curso['tratamento'] = 1
        
        df_ctrl_curso = df_pagantes[df_pagantes['cod_grupo'] == cod_curso].copy()
        df_ctrl_curso['tratamento'] = 0
        
        df_analise = pd.concat([df_trat_curso, df_ctrl_curso])
        
        resultado_psm = run_psm_analysis(
            df_analise, 'tratamento', resultado, covariates_base, 
            f'{nome_politica} - {nome_curso}',
            min_tratados=20,
            show_logit=False
        )
        resultados[nome_curso] = resultado_psm
    
    return resultados


def display_course_comparison(resultados_por_curso, nome_politica):
    """Exibe tabela comparativa entre cursos."""
    rows = []
    for curso, res in resultados_por_curso.items():
        if 'erro' not in res:
            rows.append({
                'Curso': curso,
                'N Tratados': res['n_tratados'],
                'ATT': round(res['att'], 4),
                'P-valor': round(res['p_valor'], 4),
                'Sig.': '✅' if res['significante'] else '❌',
                'Equil.': f"{res['pct_equilibradas']:.0f}%"
            })
        else:
            rows.append({
                'Curso': curso,
                'N Tratados': '-',
                'ATT': '-',
                'P-valor': '-',
                'Sig.': '⚠️',
                'Equil.': '-'
            })
    
    df_comp = pd.DataFrame(rows)
    display(Markdown(f"### Comparação por Curso: {nome_politica}"))
    display(df_comp)
    return df_comp
```

### ProUni Integral por Curso

```{python}
df_prouni_int_only = df_privadas[df_privadas['prouni_int'] == 1].copy()
resultados_prouni_curso = run_psm_vs_pagantes_by_course(
    df_prouni_int_only, df_pagantes, 'ProUni Integral'
)
display_course_comparison(resultados_prouni_curso, 'ProUni Integral vs Pagantes')
```

### FIES por Curso

```{python}
df_fies_only = df_privadas[df_privadas['fies'] == 1].copy()
resultados_fies_curso = run_psm_vs_pagantes_by_course(
    df_fies_only, df_pagantes, 'FIES'
)
display_course_comparison(resultados_fies_curso, 'FIES vs Pagantes')
```

### Auxílio Permanência por Curso (IES Públicas)

```{python}
def run_psm_by_course_publicas(tratamento, nome_politica):
    """Executa PSM por curso nas IES públicas."""
    resultados = {}
    
    for cod_curso, nome_curso in MAP_CURSO.items():
        df_curso = df_publicas[df_publicas['cod_grupo'] == cod_curso].copy()
        
        resultado_psm = run_psm_analysis(
            df_curso, tratamento, resultado, covariates_base, 
            f'{nome_politica} - {nome_curso}',
            min_tratados=20,
            show_logit=False
        )
        resultados[nome_curso] = resultado_psm
    
    return resultados

resultados_aux_curso = run_psm_by_course_publicas('aux_perm', 'Auxílio Permanência')
display_course_comparison(resultados_aux_curso, 'Auxílio Permanência (Públicas)')
```

------------------------------------------------------------------------

## Síntese dos Resultados

```{python}
todos_resultados = [
    ('ProUni Integral vs Pagantes', resultado_prouni_int, 'Privadas'),
    ('ProUni Parcial vs Pagantes', resultado_prouni_par, 'Privadas'),
    ('FIES vs Pagantes', resultado_fies, 'Privadas'),
    ('ProUni + FIES vs Pagantes', resultado_prouni_fies, 'Privadas'),
    ('Aux. Permanência', resultado_aux_perm, 'Públicas'),
    ('Aux. Alimentação', resultado_aux_alim, 'Públicas'),
    ('Aux. Perm. (Curso Gratuito)', resultado_aux_perm_gratuito, 'Gratuidade'),
    ('Aux. Alim. (Curso Gratuito)', resultado_aux_alim_gratuito, 'Gratuidade'),
]

rows_sintese = []
for nome, res, amostra in todos_resultados:
    if 'erro' not in res:
        rows_sintese.append({
            'Política': nome,
            'Amostra': amostra,
            'N Tratados': res['n_tratados'],
            'ATT': round(res['att'], 4),
            'P-valor': round(res['p_valor'], 4),
            'Sig.': '✅' if res['significante'] else '❌',
            'Equilíbrio': f"{res['pct_equilibradas']:.0f}%"
        })
    else:
        rows_sintese.append({
            'Política': nome,
            'Amostra': amostra,
            'N Tratados': '-',
            'ATT': '-',
            'P-valor': '-',
            'Sig.': '⚠️',
            'Equilíbrio': '-'
        })

df_sintese = pd.DataFrame(rows_sintese)

display(Markdown("""
### Tabela Síntese: Efeitos Estimados (ATT)

**Interpretação:**
- ATT > 0: Política associada a **aumento** na nota
- ATT < 0: Política associada a **redução** na nota
- Sig. ✅: Efeito estatisticamente significante (p < 0.05)

**Grupos de Análise:**
- **Privadas**: Comparação com estudantes pagantes (sem bolsa/financiamento)
- **Públicas**: Comparação entre beneficiários e não-beneficiários de auxílios (IES públicas)
- **Gratuidade**: Efeito de auxílios entre estudantes com curso gratuito (públicas + ProUni Integral)
"""))

display(df_sintese)
```

------------------------------------------------------------------------

::: callout-tip
## Interpretação dos Resultados

1.  **ATT Positivo e Significante:** Evidência de que a política melhora o desempenho dos beneficiários
2.  **ATT Negativo e Significante:** Evidência de que a política está associada a menor desempenho (possível viés de seleção residual)
3.  **ATT Não Significante:** Não há evidência estatística de efeito causal
4.  **Equilíbrio \< 100%:** Interpretar com cautela - nem todas as covariáveis foram equilibradas
:::

------------------------------------------------------------------------

::: callout-warning
## Limitações da Análise

1.  **Suposição de Seleção nos Observáveis:** O PSM assume que todas as variáveis relevantes para a seleção foram incluídas. Variáveis não observadas (motivação, habilidade inata) podem violar esta suposição.

2.  **Qualidade do Pareamento:** A validade das estimativas depende do equilíbrio alcançado nas covariáveis (SMD \< 0.1 para todas).

3.  **Validade Externa:** Os resultados se aplicam aos tratados observados na amostra, não necessariamente generalizáveis para toda a população.

4.  **Endogeneidade Temporal:** As políticas podem ter efeitos que se manifestam ao longo do tempo, não capturados em análise transversal.
:::